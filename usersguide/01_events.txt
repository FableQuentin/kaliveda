% KaliVeda User's Guide

# Multi-body Events #

The main business of KaliVeda is the analysis of multi-body events produced in heavy-ion reactions,
therefore it is no surprise that a central role is played by the class [KVEvent] which can be thought of as a container class for particles and nuclei (see [Particles] & [Nuclei]).
In fact there are two more event containers which are derived from [KVEvent], the full list is:

 - [KVEvent]: base class for multi-body events (container for [KVNucleus] objects);
 - [KVSimEvent]: base class for simulated multi-body events (container for [KVSimNucleus] objects);
 - [KVReconstructedEvent]: base class for reconstructed multi-body events, either experimental data or the result of ["filtering"][Filter] some simulated data (container for [KVReconstructedNucleus] objects);

In addition to containing a list of particles/nuclei, each event class also has in common the following functionality:

 - an associated list of parameters, accessible through the `GetParameters()` and `SetParameter()` methods;
 - iterators for looping over all or a subset of the particles of the event;
 - methods for defining named subsets ('groups') of particles according to various selection criteria;
 - methods for defining/modifying different relativistic reference frames in which to 'view' the particles of the event

Let us mention in passing the associated [KVEventViewer] class which can be used to produce 3D images of events using the ROOT OpenGL backend.

## Notes on usage

### Object ownership

Events are built up by repeated calls to the `AddParticle()` method which creates a new particle object (derived from `KVNucleus`), adds it to the event, and returns a pointer to the new particle.
All particles in an event __belong__ to the event and are destroyed by the `KVEvent` destructor.

Therefore a `KVEvent` cannot be used to store references to particles in another `KVEvent` object,
for example if one wants to handle a subset of the particles in the event. This is why the iterators
allow to iterate only over selected subsets of particles if required.

### Storing references to particles in an event

If you really need to store a list of references to some particles in an event, you can use an STL container, `TCollection` or [KVSeqCollection] collection class to store the particle pointers, as long as the collection does not try to delete the objects when it goes out of scope (e.g. don't use [KVList] which owns its objects by default).

### Making a copy of all or part of an event

You can if you wish copy all or part of an event, as long as you understand that the particles in the copy will be new independent objects; they will not change if you change the original event after the copy (there may also be unwanted side-effects especially for [KVReconstructedNucleus] particles).


~~~~~~~~~{.cpp}
// 'event' is a KVEvent we want to copy into new event 'event2'
KVEvent event2;
for(KVEvent::Iterator it = event.begin(); it != event.end(); ++it){
   (*it).Copy( *(event2.AddParticle()) );
}
~~~~~~~~~

### Merging several events into one

Although it is difficult/unwise to separate events into subevents, on the other hand it is possible to merge several event fragments into one single event:

~~~~~~~~~{.cpp}
// 'event_list' is a TList (for example) containing KVEvent objects to merge
KVEvent merged_event;
merged_event.MergeEventFragments(&event_list);
~~~~~~~~~

**WARNING** after merging, the subevents in the list will be empty and useless. Do not try to use them after merging!

## Iterating over particles in events

### Using `KVEvent::Iterator` iterators

Just as for STL containers, [KVEvent] provides `begin()` and `end()` methods which can be used to iterate over the particles of the event. The iterator class is [KVEvent::Iterator]:

~~~~~~~~~{.cpp}
for(KVEvent::Iterator it = event.begin(); it != event.end(); ++it){
   (*it).Print();
}

// with C++11 or later:
for(auto& n : event){
   n.Print();
}
~~~~~~~~~

The basic iterator shown above will iterate over all particles of the event. As [KVEvent::Iterator] is fully STL-compliant, you can use it with the (non-modifying) functions defined in the [std::algorithm library], as well as in a [range-based for loop] (from C++11 onwards).

#### Iterators for derived classes

The iterator dereference operator, i.e. `(*it)` in the previous example, returns a `KVNucleus&` reference (this is also the type of the `auto` variable `n` in the C++11 version). This is also the case for iterators of derived classes, e.g. although you can write

~~~~~~~~~{.cpp}
for(KVReconstructedEvent::Iterator it = reconEvent.begin(); it != reconEvent.end(); ++it){
~~~~~~~~~

assuming that `reconEvent` is a `KVReconstructedEvent` object, the iterator `it` will in fact be no different to a `KVEvent::Iterator` and `*it` will not return a `KVReconstructedNucleus&` reference.

In order to access methods which are specific to derived particle classes you can use the following methods which return a pointer or reference of the desired type:

~~~~~~~~~{.cpp}
// e.g. with KVReconstructedEvent reconEvent:
for(KVEvent::Iterator it = reconEvent.begin(); it != reconEvent.end(); ++it){
   it.pointer<KVReconstructedNucleus>()->GetStoppingDetector(); // call KVReconstructedNucleus method
}

// e.g. with KVSimEvent simulEvent:
for(KVEvent::Iterator it = simulEvent.begin(); it != reconEvent.end(); ++it){
   it.reference<KVSimNucleus>().GetSpin(); // call KVSimNucleus method
}
~~~~~~~~~


#### Example of nested loop

~~~~~~~~~{.cpp}
// Nested loops over N*(N-1)/2 distinct pairs of particles
for (KVEvent::Iterator it = event.begin(); it != event.end(); ++it) {
   KVEvent::Iterator it2(it);
   for (++it2; it2 != event.end(); ++it2) {
      cout << (*it).GetZ() << "-" << (*it2).GetZ() << " ";
   }
   cout << endl;
}

// possible output:
0-1 0-2 0-3 0-4 0-5 0-6 0-7 0-8 0-9
1-2 1-3 1-4 1-5 1-6 1-7 1-8 1-9
2-3 2-4 2-5 2-6 2-7 2-8 2-9
3-4 3-5 3-6 3-7 3-8 3-9
4-5 4-6 4-7 4-8 4-9
5-6 5-7 5-8 5-9
6-7 6-8 6-9
7-8 7-9
8-9
~~~~~~~~~

#### Iterating over particles which are "OK"

When analysing reconstructed data it is usually required to limit the iteration to only those particles which are considered to be correctly identified/calibrated, i.e. those for which the method
`KVNucleus::IsOK()` returns `true` (see [Nuclei]).

~~~~~~~~~{.cpp}
for(KVEvent::Iterator it = OKEventIterator(event).begin(); it != event.end(); ++it){
   (*it).Print();
}

// with C++11 or later:
for(auto& n : OKEventIterator(event)){
   n.Print();
}
~~~~~~~~~

#### Iterating over particles belonging to a group

If one is only interested in particles which have been previously assigned to some named group, use a `GroupEventIterator`:

~~~~~~~~~{.cpp}
// iterate over particles in group "toto"
for(KVEvent::Iterator it = GroupEventIterator(event,"toto").begin(); it != event.end(); ++it){
   (*it).Print();
}

// with C++11 or later:
for(auto& n : GroupEventIterator(event,"toto")){
   n.Print();
}
~~~~~~~~~

### [deprecated] Using `KVEvent::GetNextParticle()`

This method is kept for backwards compatibility only, you should use the `KVEvent::Iterator` iterators presented above. This method has a dangerous flaw: it uses a global (internal) iterator which means that it is not possible (or desirable) to perform two or more iterations at the same time on the same event (for example, the nested loops iteration in the examples above). 
If you want to easily replace use of this method in old code, you can use new method `KVEvent::GetNextParticleIterator()`:

~~~~~~~~~{.cpp}
/* old code:
 *   KVNucleus* nuc;
 *   while( (nuc = event.GetNextParticle(opt)) ) {
 *
 * replaced with: */
for(KVEvent::Iterator it = event.GetNextParticleIterator(opt); it!=event.end(); ++it) {
   KVNucleus* nuc = it.pointer<KVNucleus>();
~~~~~~~~~

[KVSeqCollection]: http://indra.in2p3.fr/kaliveda/doc/master/classKVSeqCollection.html
[KVList]: http://indra.in2p3.fr/kaliveda/doc/master/classKVList.html
[KVNucleus]: http://indra.in2p3.fr/kaliveda/doc/master/classKVNucleus.html
[KVEvent]: http://indra.in2p3.fr/kaliveda/doc/master/classKVEvent.html
[KVEventViewer]: http://indra.in2p3.fr/kaliveda/doc/master/classKVEventViewer.html
[KVSimNucleus]: http://indra.in2p3.fr/kaliveda/doc/master/classKVSimNucleus.html
[KVSimEvent]: http://indra.in2p3.fr/kaliveda/doc/master/classKVSimEvent.html
[KVReconstructedNucleus]: http://indra.in2p3.fr/kaliveda/doc/master/classKVReconstructedNucleus.html
[KVReconstructedEvent]: http://indra.in2p3.fr/kaliveda/doc/master/classKVReconstructedEvent.html
[Particles]: http://indra.in2p3.fr/kaliveda/doc/master/classKVParticle.html
[Nuclei]: http://indra.in2p3.fr/kaliveda/doc/master/classKVNucleus.html
[Filter]: filter.html
[KVEvent::Iterator]: http://indra.in2p3.fr/kaliveda/doc/master/classKVEvent_1_1Iterator.html
[std::algorithm library]: http://en.cppreference.com/w/cpp/algorithm
[range-based for loop]: http://en.cppreference.com/w/cpp/language/range-for
