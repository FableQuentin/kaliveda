% KaliVeda User's Guide

# Global Variables #

A global variable is an analysis tool for condensing the information in a multibody event into one or a few
characteristic values. A simple example is the event multiplicity (the number of particles in each event),
which can be used to characterize heavy-ion collision events in terms of violence or centrality.

In KaliVeda, the base class for a multibody event is [`KVEvent`{.cpp}][KVEvent], which is basically a collection of
nuclei (base class [`KVNucleus`{.cpp}][KVNucleus]). Therefore the global variable classes below can be used with any
event described by a class derived from [`KVEvent`{.cpp}][KVEvent], containing particles described by a class which
inherits from [`KVNucleus`{.cpp}][KVNucleus].

There are several base classes used for implementing global variables:

* [`KVVarGlob`{.cpp}][KVVarGlob] implements the basic interface;
* [`KVVarGlob1`{.cpp}][KVVarGlob1] is a specialised base class for global variables which calculate a single representative value;
* [`KVVarGlobMean`{.cpp}][KVVarGlobMean] is a further specialisation for variables which calculate the mean value and variance of some quantity;
* [`KVVGSum`{.cpp}][KVVGSum] is a very flexible class which can be easily configured to calculate user-defined global variables;
* [`KVGVList`{.cpp}][KVGVList] handles lists of global variables.

## Using Global Variables in Data Analysis ##

All user analysis classes for analysing multibody event data ([`KVEvent`{.cpp}][KVEvent] objects) inherit from
[`KVSelector`{.cpp}][KVSelector] or [`KVEventSelector`{.cpp}][KVEventSelector],
both of which manage a list of global variables (a [`KVGVList`{.cpp}][KVGVList]).
Users can add global variables to this list in their `InitAnalysis()`{.cpp} or `InitRun()`{.cpp} method by calling

~~~~~~~{.cpp}
KVVarGlob* KVSelector::AddGV(const Char_t* class_name, const Char_t* name)
~~~~~~~

For every event which is analysed, the list of global variables defined by the user is calculated automatically
by [`KVSelector`{.cpp}][KVSelector] just before calling the user's `Analysis()`{.cpp} method. Therefore, in `Analysis()`{.cpp},
one may retrieve the value(s) of each global variable for the event by using method

~~~~~~~{.cpp}
KVVarGlob* KVSelector::GetGV(const Char_t* name)
~~~~~~~

### Automatic creation and filling of `TTree`{.cpp} branches with global variable values ###

The [`KVGVList`{.cpp}][KVGVList] class provides methods to automatically create a branch for the value of each global
variable in the list. In your analysis ([`KVSelector`{.cpp}][KVSelector]) class, you can get a pointer to the internal list of
global variables using method

~~~~~~~{.cpp}
KVGVList* KVSelector::GetGVList()
~~~~~~~
	
Then in your `InitAnalysis()`{.cpp} or `InitRun()`{.cpp} method, after creating a `TTree`{.cpp} and filling the list of global
variables with `AddGV()`{.cpp}, you can create the necessary branches in your `TTree`{.cpp} like so:

~~~~~~~{.cpp}
TTree* myTree = new TTree(...);
AddGV(...);
AddGV(...);
GetGVList()->MakeBranches(myTree);
~~~~~~~
	
In your `Analysis()`{.cpp} method in order to fill the branches with the values of all the variables for the current
event you just need to call

~~~~~~~{.cpp}
GetGVList()->FillBranches();
myTree->Fill();
~~~~~~~

#### Controlling the number of created branches ####

For multi-valued global variables (see for example [`KVTensP`{.cpp}][KVTensP]), the default behaviour is to create
a branch for each of the values calculated by the class. Each branch will have a name of the form `toto.VARn`{.cpp}
where `toto`{.cpp} is the name of the global variable (i.e. the name given to `KVSelector::AddGV`{.cpp}) and
`VARn`{.cpp} is the name of the $n$-th value calculated.

If you don't want all values to be stored in your tree, you can choose to keep only the first $N$ values
like so:

~~~~~~~{.cpp}
AddGV("KVTensP", "tensor")->SetMaxNumBranches(3);
~~~~~~~

The resulting tree will contain the following branches:

* `tensor.ThetaFlot`
* `tensor.Sphericite`
* `tensor.Coplanarite`

corresponding to the first three values of this global variable.

Calling `KVVarGlob::SetMaxNumBranches`{.cpp} with argument 0 (zero) will effectively prevent the creation of
any branches for a given global variable. This can be used both for multi- and single-valued global variables.
	
## Using your own global variable classes ##

If you want to implement a new global variable, there are two possibilities. 
First, check that what you want to do is not possible with the [`KVVGSum`{.cpp}][KVVGSum] class.
If not, you can write your own global variable class. You need to decide first of all which base class to use
(looking at the inheritance of existing global variables may help you make your choice).
If your global variable will calculate the mean (and possibly also the variance) of some quantity, the
base class to use is [`KVVarGlobMean`{.cpp}][KVVarGlobMean].
If your global variable will calculate a single value, use [`KVVarGlob1`{.cpp}][KVVarGlob1].
If neither of the previous two cases apply, use the most general base class, [`KVVarGlob`{.cpp}][KVVarGlob].

Next, decide if your global variable is of type 1-body (calculation based on properties of individual
particles of the event, independently of the others), 2-body (calculation based on correlations between
pairs of particles), or N-body (multibody correlations) (looking at existing classes may help to decide).

Then, use one of the following methods at the ROOT command line in order to generate skeleton '.h' and
'.cpp' files for your class:

~~~~~~~{.cpp}
root[0]  KVVarGlob::MakeClass("MyClassName", "The description of my class", type)
root[0]  KVVarGlob1::MakeClass("MyClassName", "The description of my class", type)
root[0]  KVVarGlobMean::MakeClass("MyClassName", "The description of my class", type)
~~~~~~~
	
with 'type' equal to one of KVVarGlob::kOneBody, KVVarGlob::kTwoBody, KVVarGlob::kNBody.

When you have modified the skeleton according to your needs (see comments in generated code for help),
you can test the compilation of your class in a ROOT interactive session:

~~~~~~~{.cpp}
root[0]  KVBase::InitEnvironment()
root[0]  .L MyClassName.cpp+
~~~~~~~
	
### Using your own global variables in a KVSelector data analysis class ###

You need to set up your environment correctly in order to tell ROOT where to find the sources for
your global variables (this is essential for analysis tasks to run in batch mode), and in order to add
your variables to the list available for KaliVeda analysis.

First modify (or create if it doesn't exist) your '.rootrc' file, adding/modifying the following line:

~~~~~~~{.cpp}
+Unix.*.Root.MacroPath:   /full/path/to/directory/with/source/files
+ACLiC.IncludePaths:     -I/full/path/to/directory/with/source/files
~~~~~~~
	
You can use environment variables in this definition, as long as you enclose them in `'$()'`, e.g. `'$(HOME)'`.
If you have several source directories, you can put them together:

~~~~~~~{.cpp}
+Unix.*.Root.MacroPath:   /first/path:/second/path:/another/path
+ACLiC.IncludePaths:     -I/first/path -I/second/path -I/another/path
~~~~~~~
	
After relaunching ROOT, you will now be able to compile your class(es) even if you launch ROOT
in a different directory.

Next, modify (or create if it doesn't exist) your '.kvrootrc' file, adding for each of your global variables
a line like this:

~~~~~~~{.cpp}
+Plugin.KVVarGlob:  MyClassName   MyClassName  MyClassName.cpp+  "MyClassName()"
~~~~~~~
	
Then you can use your global variable in an analysis in exactly the same way as other variables:

~~~~~~~{.cpp}
[in your analysis class .cpp file]
#include "MyClassName.h"
...
MyClassName* myvg = (MyClassName*)AddGV("MyClassName", "myVarGlob");
~~~~~~~


[KVEvent]: http://indra.in2p3.fr/kaliveda/doc/master/classKVEvent.html
[KVNucleus]: http://indra.in2p3.fr/kaliveda/doc/master/classKVNucleus.html
[KVVarGlob]: http://indra.in2p3.fr/kaliveda/doc/master/classKVVarGlob.html
[KVVarGlob1]: http://indra.in2p3.fr/kaliveda/doc/master/classKVVarGlob1.html
[KVVarGlobMean]: http://indra.in2p3.fr/kaliveda/doc/master/classKVVarGlobMean.html
[KVVGSum]: http://indra.in2p3.fr/kaliveda/doc/master/classKVVGSum.html
[KVGVList]: http://indra.in2p3.fr/kaliveda/doc/master/classKVGVList.html
[KVSelector]: http://indra.in2p3.fr/kaliveda/doc/master/classKVSelector.html
[KVEventSelector]: http://indra.in2p3.fr/kaliveda/doc/master/classKVEventSelector.html
[KVTensP]: http://indra.in2p3.fr/kaliveda/doc/master/classKVTensP.html
